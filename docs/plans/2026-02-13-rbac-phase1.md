# RBAC Phase 1: Data Model & Auth Infrastructure

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish the data model, access control definitions, and auth infrastructure needed for role-based crag permissions.

**Architecture:** Two-layer RBAC — user-level roles via better-auth Admin plugin (admin/crag_creator/user), crag-level permissions via custom `crag_permissions` MongoDB collection (creator/manager). Permission utility functions centralized in `permissions.ts`, DB CRUD in `db/index.ts`.

**Tech Stack:** better-auth Admin plugin, MongoDB native driver, Vitest, TypeScript

**Design Doc:** `doc/RBAC_DESIGN.md`

---

### Task 1: Extend TypeScript types

**Files:**
- Modify: `src/types/index.ts`
- Test: Type check only (`npx tsc --noEmit`)

**Step 1: Add role and permission types to `src/types/index.ts`**

Add after the `User` interface (around line 135):

```typescript
// ==================== RBAC 权限类型 ====================

/**
 * 用户角色 (better-auth Admin 插件管理)
 */
export type UserRole = 'admin' | 'crag_creator' | 'user'

/**
 * 岩场级权限角色
 * - creator: 岩场创建者，全部权限 + 可分配 manager
 * - manager: 岩场管理者，可编辑线路/岩面/Beta (不能删除岩场)
 */
export type CragPermissionRole = 'creator' | 'manager'

/**
 * 岩场权限记录
 * 存储在 MongoDB `crag_permissions` collection
 */
export interface CragPermission {
  userId: string           // better-auth user._id (ObjectId as string)
  cragId: string           // Crag.id (e.g. 'yuan-tong-si')
  role: CragPermissionRole
  assignedBy: string       // 分配者的 userId
  createdAt: Date
}
```

**Step 2: Extend Crag interface with `createdBy`**

In the `Crag` interface (around line 96-109), add `createdBy` after `credits`:

```typescript
export interface Crag {
  // ... existing fields ...
  credits?: CragCredit[]         // 致谢人员列表
  createdBy?: string             // 创建者 userId (RBAC Phase 1 新增)
}
```

**Step 3: Run type check**

Run: `npx tsc --noEmit`
Expected: PASS (no errors — new types are additive)

**Step 4: Commit**

```bash
git add src/types/index.ts
git commit -m "$(cat <<'EOF'
feat(rbac): add UserRole, CragPermission types and Crag.createdBy field

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 2: Create permissions.ts — AC definitions and roles

**Files:**
- Create: `src/lib/permissions.ts`
- Test: `src/lib/permissions.test.ts`

**Step 1: Write the failing test**

Create `src/lib/permissions.test.ts`:

```typescript
import { describe, it, expect } from 'vitest'
import { ac, roles, canCreateCrag } from './permissions'

describe('permissions', () => {
  describe('AC definitions', () => {
    it('should export ac with custom statements', () => {
      expect(ac).toBeDefined()
      expect(ac.statements).toBeDefined()
      expect(ac.statements.editor).toEqual(['access'])
      expect(ac.statements.crag).toEqual(['create', 'update', 'delete'])
      expect(ac.statements.route).toEqual(['create', 'update', 'delete'])
      expect(ac.statements.face).toEqual(['upload', 'rename', 'delete'])
      expect(ac.statements.beta).toEqual(['approve', 'delete'])
      // inherited from defaultStatements
      expect(ac.statements.user).toBeDefined()
      expect(ac.statements.session).toBeDefined()
    })

    it('should export roles for admin, crag_creator, and user', () => {
      expect(roles.admin).toBeDefined()
      expect(roles.crag_creator).toBeDefined()
      expect(roles.user).toBeDefined()
    })
  })

  describe('canCreateCrag', () => {
    it('should allow admin to create crags', () => {
      expect(canCreateCrag('admin')).toBe(true)
    })

    it('should allow crag_creator to create crags', () => {
      expect(canCreateCrag('crag_creator')).toBe(true)
    })

    it('should deny regular user from creating crags', () => {
      expect(canCreateCrag('user')).toBe(false)
    })
  })
})
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/lib/permissions.test.ts`
Expected: FAIL with "Cannot find module './permissions'"

**Step 3: Create `src/lib/permissions.ts`**

```typescript
import { createAccessControl } from 'better-auth/plugins/access'
import { defaultStatements, adminAc } from 'better-auth/plugins/admin/access'
import type { CragPermission } from '@/types'
import { getDatabase } from '@/lib/mongodb'

// ============ Access Control 定义 ============

const statement = {
  ...defaultStatements,
  editor: ["access"] as const,
  crag:   ["create", "update", "delete"] as const,
  route:  ["create", "update", "delete"] as const,
  face:   ["upload", "rename", "delete"] as const,
  beta:   ["approve", "delete"] as const,
} as const

export const ac = createAccessControl(statement)

export const roles = {
  user: ac.newRole({}),

  crag_creator: ac.newRole({
    editor: ["access"],
    crag:   ["create", "update"],
    route:  ["create", "update", "delete"],
    face:   ["upload", "rename", "delete"],
    beta:   ["approve", "delete"],
  }),

  admin: ac.newRole({
    ...adminAc.statements,
    editor: ["access"],
    crag:   ["create", "update", "delete"],
    route:  ["create", "update", "delete"],
    face:   ["upload", "rename", "delete"],
    beta:   ["approve", "delete"],
  }),
}

// ============ 纯函数 — 无 DB 依赖 ============

/**
 * 判断用户是否可以创建岩场
 */
export function canCreateCrag(userRole: string): boolean {
  return userRole === 'admin' || userRole === 'crag_creator'
}

// ============ DB 查询权限函数 ============

/**
 * 判断用户是否可以编辑指定岩场
 * admin 可编辑所有岩场；creator/manager 可编辑被分配的岩场
 */
export async function canEditCrag(userId: string, cragId: string, userRole: string): Promise<boolean> {
  if (userRole === 'admin') return true
  const db = await getDatabase()
  const perm = await db.collection<CragPermission>('crag_permissions').findOne({ userId, cragId })
  return perm !== null
}

/**
 * 判断用户是否可以删除指定岩场
 * 只有 admin 和岩场 creator 可以删除
 */
export async function canDeleteCrag(userId: string, cragId: string, userRole: string): Promise<boolean> {
  if (userRole === 'admin') return true
  const db = await getDatabase()
  const perm = await db.collection<CragPermission>('crag_permissions').findOne({ userId, cragId, role: 'creator' })
  return perm !== null
}

/**
 * 判断用户是否可以管理岩场权限（分配/移除 manager）
 * 只有 admin 和岩场 creator 可以
 */
export async function canManagePermissions(userId: string, cragId: string, userRole: string): Promise<boolean> {
  if (userRole === 'admin') return true
  const db = await getDatabase()
  const perm = await db.collection<CragPermission>('crag_permissions').findOne({ userId, cragId, role: 'creator' })
  return perm !== null
}

/**
 * 判断用户是否可以进入编辑器
 * admin/crag_creator 始终可以；有任意 crag_permission 的 user 也可以
 */
export async function canAccessEditor(userId: string, userRole: string): Promise<boolean> {
  if (userRole === 'admin' || userRole === 'crag_creator') return true
  const db = await getDatabase()
  const perm = await db.collection<CragPermission>('crag_permissions').findOne({ userId })
  return perm !== null
}

/**
 * 获取用户可编辑的岩场 ID 列表
 * admin 返回 'all'；其他用户返回 crag_permissions 中的 cragId 列表
 */
export async function getEditableCragIds(userId: string, userRole: string): Promise<string[] | 'all'> {
  if (userRole === 'admin') return 'all'
  const db = await getDatabase()
  const perms = await db.collection<CragPermission>('crag_permissions').find({ userId }).toArray()
  return perms.map(p => p.cragId)
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run src/lib/permissions.test.ts`
Expected: PASS (3 tests)

> **Note:** If `adminAc.statements` spread causes TypeScript errors, replace with explicit listing:
> ```typescript
> admin: ac.newRole({
>   user: ["create", "list", "set-role", "ban", "impersonate", "delete", "set-password", "get", "update"],
>   session: ["list", "revoke", "delete"],
>   editor: ["access"],
>   crag: ["create", "update", "delete"],
>   route: ["create", "update", "delete"],
>   face: ["upload", "rename", "delete"],
>   beta: ["approve", "delete"],
> }),
> ```

**Step 5: Commit**

```bash
git add src/lib/permissions.ts src/lib/permissions.test.ts
git commit -m "$(cat <<'EOF'
feat(rbac): create permissions.ts with AC definitions, roles, and utility functions

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 3: Modify auth.ts — Add Admin plugin

**Files:**
- Modify: `src/lib/auth.ts:1-116`

**Step 1: Update imports and plugin config in `src/lib/auth.ts`**

Add new imports at the top (after line 4):

```typescript
import { admin } from 'better-auth/plugins'
import { ac, roles } from '@/lib/permissions'
```

Remove `user.additionalFields.role` block (lines 52-59) and replace with empty user config:

```typescript
user: {},
```

Add `admin()` to the plugins array (before `magicLink`):

```typescript
plugins: [
  admin({
    ac,
    roles,
    defaultRole: 'user',
    adminRoles: ['admin'],
  }),
  magicLink({ /* ... existing config ... */ }),
  passkey({ /* ... existing config ... */ }),
],
```

**Step 2: Run type check**

Run: `npx tsc --noEmit`
Expected: PASS

> **Troubleshooting:** If `admin` import fails, try `import { admin } from 'better-auth/plugins/admin'`.
> If `ac`/`roles` types don't match, check the `adminAc.statements` spread note in Task 2.

**Step 3: Commit**

```bash
git add src/lib/auth.ts
git commit -m "$(cat <<'EOF'
feat(rbac): integrate better-auth Admin plugin with custom AC and roles

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 4: Modify auth-client.ts — Add adminClient

**Files:**
- Modify: `src/lib/auth-client.ts:1-19`

**Step 1: Update `src/lib/auth-client.ts`**

Add import:

```typescript
import { adminClient } from 'better-auth/client/plugins'
```

Add to plugins array:

```typescript
export const authClient = createAuthClient({
  plugins: [
    adminClient(),
    magicLinkClient(),
    passkeyClient(),
  ],
})
```

> **Note:** `adminClient()` can optionally take `{ ac, roles }` for client-side permission checking. For Phase 1, the parameterless version is sufficient. Phase 4 (admin UI) may add these if needed.

**Step 2: Run type check**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 3: Commit**

```bash
git add src/lib/auth-client.ts
git commit -m "$(cat <<'EOF'
feat(rbac): add adminClient plugin to auth client

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 5: Add crag_permissions CRUD to db/index.ts

**Files:**
- Modify: `src/lib/db/index.ts` (append new section)

**Step 1: Add crag_permissions CRUD functions**

Add at the end of `src/lib/db/index.ts` (after the Avatar section, ~line 1183):

```typescript
// ============ CragPermission 相关操作 ============

import type { CragPermission, CragPermissionRole } from '@/types'

/**
 * 将 MongoDB 文档转换为 CragPermission 类型
 */
function toCragPermission(doc: WithId<Document>): CragPermission {
  return {
    userId: doc.userId as string,
    cragId: doc.cragId as string,
    role: doc.role as CragPermissionRole,
    assignedBy: doc.assignedBy as string,
    createdAt: doc.createdAt as Date,
  }
}

/**
 * 查询单条岩场权限记录
 */
export async function getCragPermission(
  userId: string,
  cragId: string
): Promise<CragPermission | null> {
  const start = Date.now()

  try {
    const db = await getDatabase()
    const doc = await db.collection('crag_permissions').findOne({ userId, cragId })

    if (!doc) return null

    log.debug(`Fetched crag permission: ${userId} → ${cragId}`, {
      action: 'getCragPermission',
      duration: Date.now() - start,
    })

    return toCragPermission(doc)
  } catch (error) {
    log.error(`Failed to get crag permission: ${userId} → ${cragId}`, error, {
      action: 'getCragPermission',
      duration: Date.now() - start,
    })
    throw error
  }
}

/**
 * 获取指定岩场的所有权限记录
 */
export async function getCragPermissionsByCragId(
  cragId: string
): Promise<CragPermission[]> {
  const start = Date.now()

  try {
    const db = await getDatabase()
    const docs = await db
      .collection('crag_permissions')
      .find({ cragId })
      .sort({ createdAt: 1 })
      .toArray()

    log.debug(`Fetched ${docs.length} permissions for crag: ${cragId}`, {
      action: 'getCragPermissionsByCragId',
      duration: Date.now() - start,
    })

    return docs.map(toCragPermission)
  } catch (error) {
    log.error(`Failed to get permissions for crag: ${cragId}`, error, {
      action: 'getCragPermissionsByCragId',
      duration: Date.now() - start,
    })
    throw error
  }
}

/**
 * 获取指定用户的所有岩场权限记录
 */
export async function getCragPermissionsByUserId(
  userId: string
): Promise<CragPermission[]> {
  const start = Date.now()

  try {
    const db = await getDatabase()
    const docs = await db
      .collection('crag_permissions')
      .find({ userId })
      .sort({ createdAt: 1 })
      .toArray()

    log.debug(`Fetched ${docs.length} permissions for user: ${userId}`, {
      action: 'getCragPermissionsByUserId',
      duration: Date.now() - start,
    })

    return docs.map(toCragPermission)
  } catch (error) {
    log.error(`Failed to get permissions for user: ${userId}`, error, {
      action: 'getCragPermissionsByUserId',
      duration: Date.now() - start,
    })
    throw error
  }
}

/**
 * 创建岩场权限记录
 * 使用 userId+cragId 唯一索引防重
 */
export async function createCragPermission(
  data: Omit<CragPermission, 'createdAt'>
): Promise<CragPermission> {
  const start = Date.now()

  try {
    const db = await getDatabase()
    const doc = {
      ...data,
      createdAt: new Date(),
    }

    await db.collection('crag_permissions').insertOne(doc)

    log.info(`Created crag permission: ${data.userId} → ${data.cragId} (${data.role})`, {
      action: 'createCragPermission',
      duration: Date.now() - start,
      metadata: { userId: data.userId, cragId: data.cragId, role: data.role },
    })

    return doc
  } catch (error) {
    log.error(`Failed to create crag permission: ${data.userId} → ${data.cragId}`, error, {
      action: 'createCragPermission',
      duration: Date.now() - start,
    })
    throw error
  }
}

/**
 * 删除岩场权限记录
 */
export async function deleteCragPermission(
  userId: string,
  cragId: string
): Promise<boolean> {
  const start = Date.now()

  try {
    const db = await getDatabase()
    const result = await db.collection('crag_permissions').deleteOne({ userId, cragId })

    log.info(`Deleted crag permission: ${userId} → ${cragId} (matched: ${result.deletedCount})`, {
      action: 'deleteCragPermission',
      duration: Date.now() - start,
    })

    return result.deletedCount > 0
  } catch (error) {
    log.error(`Failed to delete crag permission: ${userId} → ${cragId}`, error, {
      action: 'deleteCragPermission',
      duration: Date.now() - start,
    })
    throw error
  }
}

/**
 * 确保 crag_permissions collection 的索引存在
 * 在迁移脚本或应用启动时调用
 */
export async function ensureCragPermissionIndexes(): Promise<void> {
  const db = await getDatabase()
  await db.collection('crag_permissions').createIndex(
    { userId: 1, cragId: 1 },
    { unique: true }
  )
  await db.collection('crag_permissions').createIndex({ cragId: 1 })
  log.info('Ensured crag_permissions indexes', {
    action: 'ensureCragPermissionIndexes',
  })
}
```

> **Important:** The `import type { CragPermission, CragPermissionRole }` must be added to the existing import block at the top of the file (line 4), not inline. Move it to:
> ```typescript
> import type { Crag, Route, Feedback, VisitStats, CityConfig, PrefectureConfig, CragPermission, CragPermissionRole } from '@/types'
> ```

**Step 2: Run type check**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 3: Commit**

```bash
git add src/lib/db/index.ts
git commit -m "$(cat <<'EOF'
feat(rbac): add crag_permissions CRUD functions to data access layer

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 6: Create migration script

**Files:**
- Create: `scripts/migrate-crag-ownership.ts`

**Step 1: Create `scripts/migrate-crag-ownership.ts`**

```typescript
/**
 * RBAC Phase 1 迁移脚本
 *
 * 功能：
 * 1. 为所有现有岩场设置 createdBy (指向 admin 用户)
 * 2. 为 admin 创建所有岩场的 creator 权限记录
 * 3. 创建 crag_permissions 索引
 *
 * 用法：npx tsx scripts/migrate-crag-ownership.ts
 * 生产：npx tsx scripts/migrate-crag-ownership.ts production
 */

import 'dotenv/config'

// 生产环境切换
const env = process.argv[2]
if (env === 'production') {
  if (!process.env.MONGODB_URI_PROD) {
    console.error('Missing MONGODB_URI_PROD for production migration')
    process.exit(1)
  }
  process.env.MONGODB_URI = process.env.MONGODB_URI_PROD
}

// 动态导入避免 top-level await 限制
async function migrate() {
  const { getDatabase } = await import('../src/lib/mongodb')
  const db = await getDatabase()

  console.log('=== RBAC Phase 1 Migration ===\n')

  // 1. 找到 admin 用户
  const adminUser = await db.collection('user').findOne({ role: 'admin' })
  if (!adminUser) {
    console.error('ERROR: No admin user found in user collection')
    console.error('Please ensure at least one user has role: "admin"')
    process.exit(1)
  }
  const adminId = adminUser._id.toString()
  console.log(`Found admin user: ${adminUser.email} (${adminId})`)

  // 2. 为没有 createdBy 的岩场设置 createdBy
  const cragResult = await db.collection('crags').updateMany(
    { createdBy: { $exists: false } },
    {
      $set: {
        createdBy: adminId,
        updatedAt: new Date(),
      },
      // 不覆盖已有的 createdAt
      $setOnInsert: { createdAt: new Date() },
    }
  )
  console.log(`Updated ${cragResult.modifiedCount} crags with createdBy = ${adminId}`)

  // 3. 为 admin 创建 crag_permissions
  const crags = await db.collection('crags').find({}).toArray()
  console.log(`Found ${crags.length} crags total`)

  let created = 0
  let skipped = 0
  for (const crag of crags) {
    const cragId = crag._id as unknown as string
    try {
      await db.collection('crag_permissions').insertOne({
        userId: adminId,
        cragId,
        role: 'creator',
        assignedBy: adminId,
        createdAt: new Date(),
      })
      created++
    } catch (err: unknown) {
      // 重复键 = 已经存在的权限记录，跳过
      if (err && typeof err === 'object' && 'code' in err && err.code === 11000) {
        skipped++
      } else {
        throw err
      }
    }
  }
  console.log(`Created ${created} crag_permissions (skipped ${skipped} existing)`)

  // 4. 创建索引
  await db.collection('crag_permissions').createIndex(
    { userId: 1, cragId: 1 },
    { unique: true }
  )
  await db.collection('crag_permissions').createIndex({ cragId: 1 })
  console.log('Created indexes on crag_permissions')

  // 5. 验证
  const permCount = await db.collection('crag_permissions').countDocuments()
  const cragsWithCreatedBy = await db.collection('crags').countDocuments({ createdBy: { $exists: true } })
  console.log(`\n=== Verification ===`)
  console.log(`crag_permissions records: ${permCount}`)
  console.log(`crags with createdBy: ${cragsWithCreatedBy} / ${crags.length}`)
  console.log(`\n=== Migration Complete ===`)

  process.exit(0)
}

migrate().catch(err => {
  console.error('Migration failed:', err)
  process.exit(1)
})
```

**Step 2: Commit**

```bash
git add scripts/migrate-crag-ownership.ts
git commit -m "$(cat <<'EOF'
feat(rbac): add crag ownership migration script

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 7: Full build verification

**Step 1: Run all tests**

Run: `npx vitest run`
Expected: All existing tests + new permissions tests PASS

**Step 2: Run full build**

Run: `npm run build`
Expected: Build succeeds without errors

**Step 3: Run lint**

Run: `npm run lint`
Expected: No new lint errors

> **Troubleshooting common issues:**
>
> - **`adminAc.statements` type error:** Replace spread with explicit permissions (see Task 2 note)
> - **`admin` import not found:** Try `import { admin } from 'better-auth/plugins/admin'`
> - **`adminClient` import not found:** Try `import { adminClient } from 'better-auth/client/plugins'`
> - **`CragPermission` generic type error:** MongoDB's `collection<T>()` may need `Document` constraint — use `collection('crag_permissions')` without generic and cast the result instead
> - **Circular dependency warning:** Ensure permissions.ts does NOT import from auth.ts

**Step 4: Commit if any fixes were needed**

```bash
git add -A
git commit -m "$(cat <<'EOF'
fix(rbac): resolve build/lint issues from Phase 1 infrastructure

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
EOF
)"
```

---

### Task 8: Execute migration (development)

**Step 1: Run migration against development database**

Run: `npx tsx scripts/migrate-crag-ownership.ts`
Expected output:
```
=== RBAC Phase 1 Migration ===

Found admin user: <email> (<id>)
Updated N crags with createdBy = <id>
Found N crags total
Created N crag_permissions (skipped 0 existing)
Created indexes on crag_permissions

=== Verification ===
crag_permissions records: N
crags with createdBy: N / N

=== Migration Complete ===
```

**Step 2: Verify in MongoDB (optional)**

Run: `npx tsx -e "import{getDatabase}from'./src/lib/mongodb';getDatabase().then(async db=>{const c=await db.collection('crag_permissions').find({}).toArray();console.log(JSON.stringify(c,null,2));process.exit(0)})"`

**Step 3: Verify existing app functionality**

Run: `npm run dev`

Manual checks:
- [ ] Login still works
- [ ] Editor still accessible for admin
- [ ] Crag pages load correctly
- [ ] No console errors

---

## Summary of Changes

| File | Action | Description |
|------|--------|-------------|
| `src/types/index.ts` | Modify | Add `UserRole`, `CragPermissionRole`, `CragPermission`; extend `Crag` |
| `src/lib/permissions.ts` | Create | AC definitions, roles, permission utility functions |
| `src/lib/permissions.test.ts` | Create | Unit tests for AC structure and pure functions |
| `src/lib/auth.ts` | Modify | Add Admin plugin, remove `additionalFields.role` |
| `src/lib/auth-client.ts` | Modify | Add `adminClient` plugin |
| `src/lib/db/index.ts` | Modify | Add crag_permissions CRUD functions |
| `scripts/migrate-crag-ownership.ts` | Create | Migration: set createdBy + create permissions + indexes |

## Dependencies for Phase 2

Phase 2 (API Route Permission Protection) depends on these Phase 1 exports:
- `canEditCrag(userId, cragId, userRole)` — for route/face/beta/upload APIs
- `canDeleteCrag(userId, cragId, userRole)` — for crag delete API
- `canCreateCrag(userRole)` — for crag create API
- `canManagePermissions(userId, cragId, userRole)` — for crag-permissions API
- `createCragPermission(data)` — for auto-creating permission on crag creation
